<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Use three.js from an external renderer - 4.11</title>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.11/esri/themes/light/main.css"
    />
    <script src="https://js.arcgis.com/4.11/"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.js"></script>
    <script src="https://developers.arcgis.com/javascript/latest/sample-code/scene-external-renderer-threejs/live/./OBJLoader.js"></script>

    <link href='https://unpkg.com/mapillary-js@2.17.0/dist/mapillary.min.css' rel='stylesheet' />



    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      #mly {
        width: 400px;
        height: 500px;
      }

    </style>

    <!-- Our application -->
    <script>
      require([
        "esri/Map",
        "esri/views/SceneView",
        "esri/views/3d/externalRenderers",
        "esri/geometry/SpatialReference",
        "esri/request",
        "esri/core/urlUtils",
        "esri/geometry/Polygon",
        "esri/layers/GraphicsLayer",
        "esri/Graphic",
        "esri/layers/GeoJSONLayer",
        'https://unpkg.com/mapillary-js@2.17.0/dist/mapillary.min.js',
      ], function(
        Map,
        SceneView,
        externalRenderers,
        SpatialReference,
        esriRequest,
        urlUtils,
        Polygon,
        GraphicsLayer,
        Graphic,
        GeoJSONLayer,
        Mapillary
      ) {
        /*
          TODO:
            - disable navigation
            -

        */
        const CLIENT_ID = 'YzhHRGF3TExNTzkxR3JBWGxZRjNXQTowZTYyYWVmOGI0Mjg5OWFm';
        const MAPILLARY_URL = 'https://a.mapillary.com/v3/images';
        const IMAGE_URL = "https://d1cuyjsrcm0gby.cloudfront.net";

        var logo = document.createElement("img");
        var mapillaryContainer = document.createElement('div');
        mapillaryContainer.setAttribute("id", "mly");
        logo.src = "https://via.placeholder.com/150";
        var mly = null;

        const loadData = async () => {
          // add the image to the view
          view.ui.add(logo, "bottom-right");
          view.ui.add(mapillaryContainer, "bottom-left");

          mly = new Mapillary.Viewer('mly', CLIENT_ID, null);
          mly.on(Mapillary.Viewer.nodechanged, function (node) {
            issExternalRenderer.mjsPosition = [node.latLon.lon, node.latLon.lat, 405];
            view.goTo([node.latLon.lon, node.latLon.lat]);
          });

          let response = await fetch('studyAreaOffice.json')
          const data = await response.json();
          var polygon = new Polygon({ rings: data.features[0].geometry.coordinates[0] });

          var polygonGraphic = new Graphic({
            geometry: polygon,
            symbol: {
              type: "simple-fill", // autocasts as new SimpleFillSymbol()
              color: [127, 139, 179, 0.5],
              outline: {
                color: [255, 255, 255],
                width: 1
              }
            }
          });

          graphicsLayer.add(polygonGraphic);

          const { xmin, ymin, xmax, ymax } = polygon.extent;
          const url = `${MAPILLARY_URL}?bbox=${xmin},${ymin},${xmax},${ymax}&client_id=${CLIENT_ID}`;

          const geojsonLayer = new GeoJSONLayer({
            url: url,
          });

          view.on("click", function(event){
            view.hitTest(event).then(function(response) {
              // check if a feature is returned from the hurricanesLayer
              // do something with the result graphic
              const graphic = response.results.filter(function(result) {
                return result.graphic.layer === geojsonLayer;
              })[0].graphic;


              const queryParams = geojsonLayer.createQuery();
              queryParams.objectIds = [graphic.attributes.OBJECTID]

              // query the layer with the modified params object
              geojsonLayer.queryFeatures(queryParams).then(function(results){
                // prints the array of result graphics to the console
                if(results.features.length > 0) {
                  const { key } = results.features[0].attributes;
                  logo.src = `${IMAGE_URL}/${key}/thumb-320.jpg`;
                  mly.moveToKey(key);
                }
              });
            });
          });

          map.add(geojsonLayer);
        };


        // Proxy the requests to avoid CORS issues
        //////////////////////////////////////////////////////////////////////////////////////

        urlUtils.addProxyRule({
          urlPrefix: "https://open-notify-api.herokuapp.com",
          proxyUrl: "https://developers.arcgis.com/proxy/"
        });


        // Create a map
        //////////////////////////////////////////////////////////////////////////////////////
        var map = new Map({
          basemap: "gray",
          ground: "world-elevation"
        });


        /*********************
         * Add graphics layer
         *********************/

        var graphicsLayer = new GraphicsLayer();
        map.add(graphicsLayer);

        // Create a SceneView
        //////////////////////////////////////////////////////////////////////////////////////
        var view = new SceneView({
          container: "viewDiv",
          map: map,
          viewingMode: "global",
          camera: {
            heading: 0,
            tilt: 45, // looking from a bird's eye view
            position: {
              latitude: 47.389,
              longitude: 8.5099,
              z: 900,
              spatialReference: { wkid: 3857 }
            }
          }
        });
        /*
        view.on("drag", function(event) {
          // prevents panning with the mouse drag event
          event.stopPropagation();
        });

        view.on("key-down", function(event) {
          // prevents panning with the arrow keys
          var keyPressed = event.key;
          if (keyPressed.slice(0, 5) === "Arrow") {
            event.stopPropagation();
          }
        });
        */

        /***************************
         * Add a 3D polygon graphic
         ***************************/

        // make request to map
        loadData();









        // Disable lighting based on the current camera position.
        // We want to display the lighting according to the current time of day.
        view.environment.lighting.cameraTrackingEnabled = false;

        // Create our custom external renderer
        //////////////////////////////////////////////////////////////////////////////////////

        var issExternalRenderer = {
          renderer: null, // three.js renderer
          camera: null, // three.js camera
          scene: null, // three.js scene

          ambient: null, // three.js ambient light source
          sun: null, // three.js sun light source

          iss: null, // ISS model
          issScale: 0.01, // scale for the iss model
          issMaterial: new THREE.MeshLambertMaterial({ color: 0xe03110 }), // material for the ISS model

          cameraPositionInitialized: true, // we focus the view on the ISS once we receive our first data point
          positionHistory: [], // all ISS positions received so far

          mjsPosition : [0, 0, 0],

          markerMaterial: null, // material for the markers left by the ISS
          markerGeometry: null, // geometry for the markers left by the ISS

          /**
           * Setup function, called once by the ArcGIS JS API.
           */
          setup: function(context) {
            // initialize the three.js renderer
            //////////////////////////////////////////////////////////////////////////////////////
            this.renderer = new THREE.WebGLRenderer({
              context: context.gl,
              premultipliedAlpha: false
            });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setViewport(0, 0, view.width, view.height);

            // prevent three.js from clearing the buffers provided by the ArcGIS JS API.
            this.renderer.autoClearDepth = false;
            this.renderer.autoClearStencil = false;
            this.renderer.autoClearColor = false;

            // The ArcGIS JS API renders to custom offscreen buffers, and not to the default framebuffers.
            // We have to inject this bit of code into the three.js runtime in order for it to bind those
            // buffers instead of the default ones.
            var originalSetRenderTarget = this.renderer.setRenderTarget.bind(
              this.renderer
            );
            this.renderer.setRenderTarget = function(target) {
              originalSetRenderTarget(target);
              if (target == null) {
                context.bindRenderTarget();
              }
            };

            // setup the three.js scene
            ///////////////////////////////////////////////////////////////////////////////////////

            this.scene = new THREE.Scene();

            // setup the camera
            this.camera = new THREE.PerspectiveCamera();

            // setup scene lighting
            this.ambient = new THREE.AmbientLight(0xffffff, 0.5);
            this.scene.add(this.ambient);
            this.sun = new THREE.DirectionalLight(0xffffff, 0.5);
            this.scene.add(this.sun);

            // setup markers
            this.markerGeometry = new THREE.SphereBufferGeometry(
              12 * 1000,
              16,
              16
            );
            this.markerMaterial = new THREE.MeshBasicMaterial({
              color: 0xe03110,
              transparent: true,
              opacity: 0.75
            });

            // load ISS mesh
            var issMeshUrl = "deer.obj";
            var loader = new THREE.OBJLoader(THREE.DefaultLoadingManager);
            loader.load(
              issMeshUrl,
              function(object3d) {
                console.log("ISS mesh loaded.");
                this.iss = object3d;

                // apply ISS material to all nodes in the geometry
                this.iss.traverse(
                  function(child) {
                    if (child instanceof THREE.Mesh) {
                      child.material = this.issMaterial;
                    }
                  }.bind(this)
                );

                // set the specified scale for the model
                this.iss.scale.set(this.issScale, this.issScale, this.issScale);

                // add the model
                this.scene.add(this.iss);
              }.bind(this),
              undefined,
              function(error) {
                console.error("Error loading ISS mesh. ", error);
              }
            );


            // cleanup after ourselfs
            context.resetWebGLState();
          },

          render: function(context) {
            // update camera parameters
            ///////////////////////////////////////////////////////////////////////////////////
            var cam = context.camera;

            this.camera.position.set(cam.eye[0], cam.eye[1], cam.eye[2]);
            this.camera.up.set(cam.up[0], cam.up[1], cam.up[2]);
            this.camera.lookAt(
              new THREE.Vector3(cam.center[0], cam.center[1], cam.center[2])
            );

            // Projection matrix can be copied directly
            this.camera.projectionMatrix.fromArray(cam.projectionMatrix);

            // update ISS and region position
            ///////////////////////////////////////////////////////////////////////////////////
            if (this.iss) {
              var posEst = this.mjsPosition; // this.computeISSPosition();

              var renderPos = [0, 0, 0];
              externalRenderers.toRenderCoordinates(
                view,
                posEst,
                0,
                SpatialReference.WGS84,
                renderPos,
                0,
                1
              );
              this.iss.position.set(renderPos[0], renderPos[1], renderPos[2]);

              // for the region, we position a torus slightly under ground
              // the torus also needs to be rotated to lie flat on the ground
              posEst = [posEst[0], posEst[1], -450 * 1000];

              var transform = new THREE.Matrix4();
              transform.fromArray(
                externalRenderers.renderCoordinateTransformAt(
                  view,
                  posEst,
                  SpatialReference.WGS84,
                  new Array(16)
                )
              );
            }

            // update lighting
            /////////////////////////////////////////////////////////////////////////////////////////////////////
            view.environment.lighting.date = Date.now();

            var l = context.sunLight;
            this.sun.position.set(
              l.direction[0],
              l.direction[1],
              l.direction[2]
            );
            this.sun.intensity = l.diffuse.intensity;
            this.sun.color = new THREE.Color(
              l.diffuse.color[0],
              l.diffuse.color[1],
              l.diffuse.color[2]
            );

            this.ambient.intensity = l.ambient.intensity;
            this.ambient.color = new THREE.Color(
              l.ambient.color[0],
              l.ambient.color[1],
              l.ambient.color[2]
            );

            // draw the scene
            /////////////////////////////////////////////////////////////////////////////////////////////////////
            this.renderer.resetGLState();
            this.renderer.render(this.scene, this.camera);

            // as we want to smoothly animate the ISS movement, immediately request a re-render
            externalRenderers.requestRender(view);

            // cleanup
            context.resetWebGLState();
          },

          lastPosition: null,
          lastTime: null,
        };

        // register the external renderer
        externalRenderers.add(view, issExternalRenderer);
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
  </body>
</html>
